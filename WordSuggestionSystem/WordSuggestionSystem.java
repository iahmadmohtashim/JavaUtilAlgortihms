import java.util.*;public class WordSuggestionSystem {    private NGramModel nGramModel;    private Set<String> vocabulary;    private static final int MAX_SUGGESTIONS = 5;    private static final double MIN_SIMILARITY = 0.3;    public WordSuggestionSystem() {        this.nGramModel = new NGramModel();        this.vocabulary = new HashSet<>();    }    public void train(String text) {        // Preprocess text        text = text.toLowerCase().replaceAll("[^a-z\\s]", "");                // Update vocabulary        Collections.addAll(vocabulary, text.split("\\s+"));                // Train n-gram model        nGramModel.train(text);    }    public List<WordSuggestion> getSuggestions(String partialWord) {        partialWord = partialWord.toLowerCase();        List<WordSuggestion> suggestions = new ArrayList<>();        // Get similar words based on string similarity        for (String word : vocabulary) {            double similarity = calculateSimilarity(partialWord, word);            if (similarity >= MIN_SIMILARITY) {                double score = similarity * nGramModel.getWordProbability(word);                suggestions.add(new WordSuggestion(word, score));            }        }        // Sort suggestions by score and limit to MAX_SUGGESTIONS        Collections.sort(suggestions);        return suggestions.subList(0, Math.min(MAX_SUGGESTIONS, suggestions.size()));    }    public List<WordSuggestion> getNextWordSuggestions(String currentWord) {        currentWord = currentWord.toLowerCase();        List<WordSuggestion> suggestions = new ArrayList<>();        Map<String, Integer> nextWordCounts = nGramModel.getNextWordCounts(currentWord);        int totalCount = nextWordCounts.values().stream().mapToInt(Integer::intValue).sum();                for (Map.Entry<String, Integer> entry : nextWordCounts.entrySet()) {            double probability = (double) entry.getValue() / totalCount;            suggestions.add(new WordSuggestion(entry.getKey(), probability));        }        Collections.sort(suggestions);        return suggestions.subList(0, Math.min(MAX_SUGGESTIONS, suggestions.size()));    }    private double calculateSimilarity(String s1, String s2) {        // Implement Levenshtein distance-based similarity        int distance = levenshteinDistance(s1, s2);        int maxLength = Math.max(s1.length(), s2.length());        return 1.0 - ((double) distance / maxLength);    }    private int levenshteinDistance(String s1, String s2) {        int[][] dp = new int[s1.length() + 1][s2.length() + 1];        for (int i = 0; i <= s1.length(); i++) {            dp[i][0] = i;        }        for (int j = 0; j <= s2.length(); j++) {            dp[0][j] = j;        }        for (int i = 1; i <= s1.length(); i++) {            for (int j = 1; j <= s2.length(); j++) {                int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;                dp[i][j] = Math.min(Math.min(                    dp[i - 1][j] + 1,     // deletion                    dp[i][j - 1] + 1),    // insertion                    dp[i - 1][j - 1] + cost); // substitution            }        }        return dp[s1.length()][s2.length()];    }}